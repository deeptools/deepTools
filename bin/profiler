#!/usr/bin/env python
#-*- coding: utf-8 -*-

from __future__ import division
import sys

import argparse
import numpy as np
from matplotlib import use
use('Agg')
import matplotlib.pyplot as plt
from matplotlib.font_manager import FontProperties
from matplotlib import colors as pltcolors
import matplotlib.gridspec as gridspec

# own modules
from deeptools import parserCommon
from deeptools import heatmapper
from deeptools.heatmapper_utilities import plot_single, getProfileTicks

debug = 0
plt.ioff()


def parse_arguments(args=None):
    parser = argparse.ArgumentParser(
        parents=[parserCommon.heatmapperMatrixArgs(),
                 parserCommon.heatmapperOutputArgs(mode='profile'),
                 parserCommon.heatmapperOptionalArgs(mode='profile')],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description='This tool creates a profile plot for a '
        'score associated to genomic regions. '
        'Typically, these regions are genes, but '
        'any other regions defined in a BED or GFF '
        'format will work. A preprocessed matrix generated '
        'by the tool computeMatrix is required.',
        epilog='An example usage is: %(prog)s -m <matrix file>',
        add_help=False)

    args = parser.parse_args(args)

    # Because of galaxy, the value of this variables is normally
    # set to ''. Therefore this check is needed
    for attr in ['yMax', 'yMin']:
        try:
            args.__setattr__(attr, float(args.__getattribute__(attr)))
#       except ValueError, TypeError:
        except:
            args.__setattr__(attr, None)

    if args.plotHeight < 0.5:
        args.plotHeight = 0.5
    elif args.plotHeight > 100:
        args.plotHeight = 100

    if args.regionsLabel != 'genes':
        args.regionsLabel = \
            [x.strip() for x in args.regionsLabel.split(',')]

        if len(set(args.regionsLabel)) != len(args.regionsLabel):
            print "The group labels given contain repeated names. Please "
            "give a unique name to each value. The values given are "
            "{}\n".format(args.regionsLabel)
            exit(1)
    else:
        args.regionsLabel = []

    return args


def plotProfile(hm, outFileName,
                plotTitle='',
                yAxislabel='',
                yMin=None, yMax=None,
                averagetype='median',
                referencePointLabel='TSS',
                startLabel='TSS', endLabel="TES",
                plotHeight=7,
                plotWidth=11,
                perGroup=False,
                plotType='simple',
                image_format=None,
                color_list=None,
                legend_location='auto',
                plots_per_row=8):

    """
    Using the hm matrix, makes a line plot
    either per group or per sample
    using the specified parameters.
    """
    # the following line is to temporary compute the log
    # of the matrix
    # hm.matrix.matrix = np.log(hm.matrix.matrix)

    # decide how many plots are needed
    if perGroup:
        numplots = hm.matrix.get_num_groups()
        numlines = hm.matrix.get_num_samples()
    else:
        numplots = hm.matrix.get_num_samples()
        numlines = hm.matrix.get_num_groups()

    if numplots > plots_per_row:
        rows = np.ceil(numplots / plots_per_row).astype(int)
        cols = plots_per_row
    else:
        rows = 1
        cols = numplots
    grids = gridspec.GridSpec(rows, cols)

    plt.rcParams['font.size'] = 10.0
    font_p = FontProperties()
    font_p.set_size('small')
#    rcParams['font.size'] = 9.0

    # convert cm values to inches
    plotHeightInches = rows * float(plotHeight) / 2.54
    figWidth = cols * float(plotWidth) / 2.54 
    fig = plt.figure(figsize=(figWidth, plotHeightInches))

    # add xticks and labels to the last plot
    # define the xticks

    fig.suptitle(plotTitle, y=(1 - (0.06 / plotHeightInches)))

    if not color_list:
        cmap_plot = plt.get_cmap('jet')
        if numlines > 1:
            #kmeans, so we need to color by cluster
            color_list = cmap_plot(np.arange(numlines, dtype=float) / numlines)
        else :
            color_list = cmap_plot(np.arange(numplots, dtype=float) / numplots)
    else:
        if (numlines > 1 and len(color_list) < numlines) or (numlines == 1 and len(color_list) < numplots) :
            sys.stderr.write("\nThe given list of colors is too small, "
                             "at least {} colors are needed\n".format(numlines))
            exit(1)
        for color in color_list:
            if not pltcolors.is_color_like(color):
                sys.stderr.write("\nThe color name {} is not valid. Check "
                                 "the name or try with a html hex string "
                                 "for example #eeff22".format(color))

                exit(1)

    xticks, xtickslabel = getProfileTicks(hm, referencePointLabel,
                                          startLabel, endLabel)
    first = True
    sample_ymax = None
    sample_ymin = None
    ax_list = []
    for plot in range(numplots):
        col = plot % plots_per_row
        row = int(plot / plots_per_row)
        if row == 0 and col == 0:
            ax = fig.add_subplot(grids[row, col])
        else:
            ax = fig.add_subplot(grids[row, col], sharey=ax_list[0])

        if perGroup:
            title = hm.matrix.group_labels[plot]
            if row != 0:
                plt.setp(ax.get_yticklabels(), visible=False)
        else:
            title = hm.matrix.sample_labels[plot]
            if col != 0:
                plt.setp(ax.get_yticklabels(), visible=False)

        ax.set_title(title)
        mat = []  # when drawing a heatmap (in contrast to drawing lines)
        for data_idx in range(numlines):
            if perGroup:
                row, col = plot, data_idx
            else:
                row, col = data_idx, plot

            sub_matrix = hm.matrix.get_matrix(row, col)

            if perGroup:
                label = sub_matrix['sample']
            else:
                label = sub_matrix['group']

            if plotType == 'heatmap':
                # if plotting a heatmap, the individual rows
                # need to be collected before plotting
                mat.append(np.__getattribute__(averagetype)(sub_matrix['matrix'],
                                                            axis=0))
            else:
                if numlines > 1:
                    coloridx = data_idx
                else :
                    coloridx = plot
                plot_single(ax, sub_matrix['matrix'],
                            averagetype,
                            color_list[coloridx],
                            label,
                            plot_type=plotType)

        if plotType == 'heatmap':
            ax.imshow(np.asmatrix(mat), interpolation='nearest', cmap='seismic_r')

        if (perGroup and row > 0) or (perGroup is False and col > 0):
            # remove the numbers of the y axis for all plots
            # except the first one
            plt.setp(ax.get_yticklabels(), visible=False)
        else:
            # add the y axis label for the first plot
            ax.axes.set_ylabel(yAxislabel)
            """
            # reduce the number of yticks by half
            num_ticks = len(ax.get_yticks())
            yticks = [ax.get_yticks()[i] for i in range(1, num_ticks, 2)]
            ax.set_yticks(yticks)
            """

        ax.axes.set_xticks(xticks)
        ax.axes.set_xticklabels(xtickslabel)
        # align the first and last label
        # such that they don't fall off 
        # the heatmap sides
        ticks = ax.xaxis.get_major_ticks()
        ticks[0].label1.set_horizontalalignment('left')
        ticks[-1].label1.set_horizontalalignment('right')

        if first:
            ax.legend(loc=legend_location.replace('-', ' '),
                      ncol=1, prop=font_p,
                      frameon=False, markerscale=0.5)
            first = False
        """
        ax.legend(bbox_to_anchor=(-0.05, -1.13, 1., 1),
                  loc='upper center',
                  ncol=1, mode="expand", prop=font_p,
                  frameon=False, markerscale=0.5)
        """

        ax.set_ylim(yMin, yMax)

        ax_list.append(ax)

    plt.subplots_adjust(wspace=0.05, hspace=0.3)
    plt.tight_layout()
    plt.savefig(outFileName, dpi=200, format=image_format)


def main(args):
    r"""
    >>> import filecmp
    >>> import os
    >>> args = parseArguments(
    ... "-m ../deeptools/test/test_heatmapper/master.mat.gz \
    ... --outFileName /tmp/_test.png --regionsLabel uno,dos \
    ... --plotType std".split())
    >>> main(args)
    >>> filecmp.cmp(
    ... '../deeptools/test/test_heatmapper/profile_master.png',
    ... '/tmp/_test.png')
    True
    >>> os.remove('/tmp/_test.png')

    """

    hm = heatmapper.heatmapper()
    matrix_file = args.matrixFile.name
    args.matrixFile.close()
    hm.readMatrixFile(matrix_file,
                      default_group_name=args.regionsLabel)

    if args.kmeans is not None:
        hm.matrix.hmcluster(args.kmeans, method='kmeans')

    if len(args.regionsLabel):
        hm.matrix.set_group_labels(args.regionsLabel)

    if args.samplesLabel and len(args.samplesLabel):
        hm.matrix.set_sample_labels(args.samplesLabel)

    #if args.outFileNameData:
    #    hm.saveTabulatedValues(args.outFileNameData)

    if args.outFileSortedRegions:
        hm.saveBED(args.outFileSortedRegions)

    plotProfile(hm,
                args.outFileName,
                args.plotTitle,
                args.yAxisLabel,
                args.yMin, args.yMax,
                args.averageType,
                args.refPointLabel,
                args.startLabel,
                args.endLabel,
                args.plotHeight,
                args.plotWidth,
                args.perGroup,
                plotType=args.plotType,
                image_format=args.plotFileFormat,
                color_list=args.colors,
                legend_location=args.legendLocation,
                plots_per_row=args.numPlotsPerRow)

if __name__ == "__main__":
    ARGS = parse_arguments()
    main(ARGS)

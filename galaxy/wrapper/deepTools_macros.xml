<macros>

    <token name="@THREADS@">--numberOfProcessors "\${GALAXY_SLOTS:-4}"</token>
    <token name="@WRAPPER_VERSION@">3.0.2</token>
    <xml name="requirements">
        <requirements>
            <requirement type="package" version="3.0.2">deeptools</requirement>
            <requirement type="package" version="1.7">samtools</requirement>
        </requirements>
        <expand macro="stdio" />
        <version_command>@BINARY@ --version</version_command>
    </xml>

    <xml name="advancedOpt_scaffold">
        <conditional name="advancedOpt">
            <param name="showAdvancedOpt" type="select" label="Show advanced options" >
                <option value="no" selected="true">no</option>
                <option value="yes">yes</option>
            </param>
            <when value="no" />
            <when value="yes">
                <yield/>
            </when>
        </conditional>
    </xml>

    <token name="@PLOTWIDTHHEIGHT@">
        --plotWidth '$advancedOpt.plotWidth'
        --plotHeight '$advancedOpt.plotHeight'
    </token>

    <xml name="plotWidthHeight" tokens="PLOTWIDTH,PLOTHEIGHT">
        <param argument="--plotHeight" type="float" value="@PLOTHEIGHT@" min="1.0"
            label="Plot height"
            help="Height in cm. The default for the plot height is @PLOTHEIGHT@ centimeters. The minimum value is 1 cm." />

        <param argument="--plotWidth" type="float" value="@PLOTWIDTH@" min="1.0"
            label="Plot width"
            help="Width in cm. The default value is @PLOTWIDTH@ centimeters. The minimum value is 1 cm." />
    </xml>

    <token name="@ADVANCED_OPTS_READ_PROCESSING@">
        #if $advancedOpt.doExtendCustom.doExtend == 'custom':
            --extendReads $advancedOpt.doExtendCustom.extendReadsValue
        #else if $advancedOpt.doExtendCustom.doExtend == 'yes':
            --extendReads
        #end if
        $advancedOpt.ignoreDuplicates
        $advancedOpt.centerReads
        #if $advancedOpt.minMappingQuality:
            --minMappingQuality '$advancedOpt.minMappingQuality'
        #end if
        #if $advancedOpt.samFlagInclude:
            --samFlagInclude $advancedOpt.samFlagInclude
        #end if
        #if $advancedOpt.samFlagExclude:
            --samFlagExclude $advancedOpt.samFlagExclude
        #end if
        #if $advancedOpt.minFragmentLength:
            --minFragmentLength $advancedOpt.minFragmentLength
        #end if
        #if $advancedOpt.maxFragmentLength:
            --maxFragmentLength $advancedOpt.maxFragmentLength
        #end if
    </token>

    <token name="@ADVANCED_OPTS_GTF@">
        $advancedOpt.metagene
        #if $advancedOpt.transcriptID:
            --transcriptID $advancedOpt.transcriptID
        #end if
        #if $advancedOpt.exonID:
            --exonID $advancedOpt.exonID
        #end if
        #if $advancedOpt.transcript_id_designator:
            --transcript_id_designator $advancedOpt.transcript_id_designator
        #end if
    </token>

    <xml name="heatmap_options">
        <expand macro="zMin_zMax" />
        <expand macro="colorMap" />
        <expand macro="plotTitle" />
        <expand macro="plotNumbers" />
    </xml>

    <token name="@HEATMAP_OPTIONS@">
        #if str($plotting_type.zMin) != "":
            --zMin $plotting_type.zMin
        #end if
        #if str($plotting_type.zMax) != "":
            --zMax $plotting_type.zMax
        #end if
        --colorMap '$plotting_type.colorMap'
        $plotting_type.plotNumbers
        --plotTitle '$plotting_type.plotTitle'
    </token>


    <xml name="includeZeros">
        <param argument="--includeZeros" type="boolean" truevalue="--includeZeros" falsevalue=""
            label="Include zeros"
            help="If set, then regions with zero counts for *all* BAM/CRAM files are included. The default behavior is to ignore such regions." />
    </xml>

    <xml name="zMin_zMax">
        <param argument="--zMin" type="text" value="" optional="true" label="Minimum value for the heatmap intensities"
            help="If not specified the value is set automatically."/>
        <param argument="--zMax" type="text" value="" optional="true" label="Maximum value for the heatmap intensities"
            help="If not specified the value is set automatically."/>
    </xml>

    <xml name="region_limit_operation">
        <param argument="--region" type="text" value=""
            label="Region of the genome to limit the operation to"
            help="This is useful when testing parameters to reduce the time required. The format is chr:start:end, for example &quot;chr10&quot; or &quot;chr10:456700:891000&quot;.">
            <sanitizer>
                <valid initial="string.letters,string.digits">
                    <add value="|"/>
                    <add value=":"/>
                    <add value="."/>
                 </valid>
            </sanitizer>
        </param>
    </xml>

    <xml name="smoothLength">
        <param argument="--smoothLength" type="integer" value="" optional="True" min="1"
            label="Smooth values using the following length (in bases)"
            help ="The smooth length defines a window, larger than the bin size, over which the number of reads is to be averaged. For example, if the bin size is set to 20 and the smooth length is 60, then, for each bin, its value is set to the average of it and its left and right neighbors. Any value smaller than the bin size will be ignored and no smoothing will be applied."/>
    </xml>


    <xml name="kmeans_clustering">
        <conditional name="used_multiple_regions">
            <param name="used_multiple_regions_options" type="select"
                label="Did you compute the matrix with more than one groups of regions?"
                help="Would you like to cluster the regions according to the similarity of the signal distribution? This is only possible if you used computeMatrix on only one group of regions.">
                <option value="yes">Yes, I used multiple groups of regions</option>
                <option value="no">No, I used only one group</option>
            </param>
            <when value="no">
                <conditional name="clustering">
                    <param name="clustering_options" type="select" label="Clustering algorithm">
                        <option value="none">No clustering</option>
                        <option value="kmeans">Kmeans clustering</option>
                        <option value="hclust">Hierarchical clustering</option>
                    </param>
                    <when value="kmeans">
                        <param name="k_kmeans" type="integer" value="0" label="Number of clusters to compute"
                            help="When this option is set, the matrix is split into clusters using the k-means algorithm.
                            This only works for data that is not grouped, otherwise only the first group will be clustered.
                            If more specific clustering methods are required it is advisable to save the underlying matrix and
                            run the clustering using other software."/>
                    </when>
                    <when value="hclust">
                        <param name="n_hclust" type="integer" value="0" label="number of clusters to compute."
                            help="WARNING: This option causes the tool to run for a very long time! When this option is
                            set, the matrix is split into clusters using the hierarchical clustering algorithm, using ward linkage.
                            This only works for data that is not grouped, otherwise only the first group will be clustered.
                            Note that you must have used the '--missingDataAsZero' option within computeMatrix!
                            If more specific clustering methods are required it is advisable to save the underlying matrix and
                            run the clustering using other software."/>
                    </when>
                    <when value="none" />
                </conditional>
            </when>
            <when value="yes" />
        </conditional>
    </xml>

    <token name="@KMEANS_CLUSTERING@">
        #if $advancedOpt.used_multiple_regions.used_multiple_regions_options == 'no':
            #if $advancedOpt.used_multiple_regions.clustering.clustering_options == 'kmeans':
                #if int($advancedOpt.used_multiple_regions.clustering.k_kmeans) > 0:
                    --kmeans $advancedOpt.used_multiple_regions.clustering.k_kmeans
                #end if
            #end if
            #if $advancedOpt.used_multiple_regions.clustering.clustering_options == 'hclust':
                #if int($advancedOpt.used_multiple_regions.clustering.n_hclust) > 0:
                    --hclust $advancedOpt.used_multiple_regions.clustering.n_hclust
                #end if
            #end if
        #end if
    </token>

    <xml name="samFlags">
        <param argument="--samFlagInclude" type="integer" optional="True" value=""
            label="Include reads based on the SAM flag"
            help= "For example, to get only reads that are the first mate use a flag of 64. This is useful to count properly paired reads only once, otherwise the second mate will be also considered for the coverage."/>
        <param argument="--samFlagExclude" type="integer" optional="True" value=""
            label="Exclude reads based on the SAM flag"
            help= "For example, to get only reads that map to the forward strand, use --samFlagExclude 16, where 16 is the SAM flag for reads that map to the reverse strand."/>
    </xml>

    <xml name="fragLength">
        <param argument="--minFragmentLength" type="integer" optional="True" value="0" min="0"
            label="Minimum fragment length for inclusion."
            help="This is primarily useful in things like ATACseq, where one would like to look specifically at mono- or di-nucleosome fragments." />
        <param argument="--maxFragmentLength" type="integer" optional="True" value="0" min="0"
            label="Maximum fragment length for inclusion."
            help="A value of 0 (the default) is equivalent to no maximum." />
    </xml>

    <xml name="read_processing_options">
        <expand macro="extendReads" />
        <expand macro="ignoreDuplicates" />
        <expand macro="centerReads" />
        <expand macro="minMappingQuality" />
        <expand macro="samFlags" />
        <expand macro="fragLength" />
    </xml>

    <xml name="gtf_options">
        <param argument="--metagene" type="boolean" truevalue="--metagene" falsevalue=""
            label="Use a metagene model"
            help="If set and a BED12 or GTF file or files is used to provide regions, only exons will be used. This is convenient for looking at coverage over mature mRNA transcripts or similar uses where introns should be ignored." />
        <param argument="--transcriptID" optional="True" value="transcript" type="text"
            label="trascript designator"
            help="When a GTF file is used to provide regions, only entries with this value as their feature (column 2) will be processed as transcripts. Default: transcript" />
        <param argument="--exonID" optional="True" value="exon" type="text"
            label="exon designator"
            help="When a GTF file is used to provide regions, only entries with this value as their feature (column 2) will be processed as exons. CDS would be another common value for this. Default: exon" />
        <param argument="--transcript_id_designator" optional="True" value="transcript_id" type="text"
            label="transcriptID key designator"
            help="Each region has an ID (e.g., ACTB) assigned to it, which for BED files is either column 4 (if it exists)
                  or the interval bounds. For GTF files this is instead stored in the last column as a key:value pair (e.g.,
                  as 'transcript_id ACTB', for a key of transcript_id and a value of ACTB). In some cases it can be
                  convenient to use a different identifier. To do so, set this to the desired key. Default: transcript_id" />
    </xml>


    <xml name="plotNumbers">
        <param argument="--plotNumbers" type="boolean" truevalue="--plotNumbers" falsevalue=""
            label="Plot the correlation value"
            help="If set, then the correlation number is plotted on top of the heatmap."/>
    </xml>

    <xml name="extendReads">
        <conditional name="doExtendCustom">
            <param name="doExtend" type="select" label="Extend reads to the given average fragment size."
                help="If selected : Single-end reads and singletons are extended to match the given length and Paired-end reads are extended to match the fragment size.
                     By default *each* read mate is extended.
                     This can be modified using the SAM flags (see --samFlagInclude and --samFlagExclude options) to keep only the first or the second mate.
                     Unmated reads, mate reads that map to different chromosomes or too far apart are extended to the given value.
                     Reads are only extended if --extendReads is set to a value greater than the read length. *NOTE*: For spliced-read data, this option is not
                     recommended as it will extend reads over skipped regions, e.g. introns in RNA-seq data.">
                <option value="no" selected="True">No extension. The default value and most typically appropriate.</option>
                <option value="yes">Paired-end extension. Suitable only for paired-end datasets.</option>
                <option value="custom">A custom length, which will be applied to ALL reads.</option>
            </param>
            <when value="no" />
            <when value="yes" />
            <when value="custom">
                <param name="extendReadsValue" type="integer" value="300" min="1"
                    label="Extend reads to the given average fragment size"
                    help="Extend all reads to this length" />
            </when>
        </conditional>
    </xml>

    <xml name="corMethod">
        <param argument="--corMethod" type="select" label="Correlation method">
            <option value="spearman" selected="True">Spearman</option>
            <option value="pearson">Pearson</option>
        </param>
    </xml>

    <xml name="distanceBetweenBins">
        <param argument="--distanceBetweenBins" type="integer" value="0" min="0"
            label="Distance between bins"
            help="By default, multiBamSummary considers consecutive bins of
                the specified 'Bin size'. However, to reduce the
                computation time, a larger distance between bins can
                be given. Larger distances result in fewer bins being
                considered."/>
    </xml>

    <xml name="centerReads">
        <param argument="--centerReads" type="boolean" truevalue="--centerReads" falsevalue=""
            label="Center regions with respect to the fragment length"
            help="For paired-end data the fragment is defined by the bounds of the reads. For single-end data the bounds are defined by the read and the user-definable fragment/extension length. This option is useful to get a sharper signal around enriched regions."/>
    </xml>

    <xml name="ignoreDuplicates">
        <param argument="--ignoreDuplicates" type="boolean" truevalue="--ignoreDuplicates" falsevalue=""
            label="Ignore duplicates"
            help="If set, reads that have the same orientation and start position will be considered only once. If reads are paired, the mate position also has to coincide to ignore a read." />
    </xml>

    <xml name="sortUsing">
        <param argument="--sortUsing" type="select" label="Method used for sorting"
            help="For each row the method is computed.">
            <option value="mean" selected="true">mean</option>
            <option value="median">median</option>
            <option value="min">min</option>
            <option value="max">max</option>
            <option value="sum">sum</option>
            <option value="region_length">region length</option>
        </param>
    </xml>

    <xml name="sortRegionsComputeMatrix">
        <param argument="--sortRegions" type="select" label="Sort regions"
            help="Whether the heatmap should present the regions sorted. The default is to sort in descending order based on the mean value per region.">
            <option value="no">no ordering</option>
            <option value="keep" selected="true">maintain the same ordering as the input files</option>
            <option value="descend">descending order</option>
            <option value="ascend">ascending order</option>
        </param>
    </xml>

    <xml name="sortRegions">
        <param argument="--sortRegions" type="select" label="Sort regions"
            help="Whether the heatmap should present the regions sorted. The default is to sort in descending order based on the mean value per region.">
            <option value="no">maintain the same ordering as the input files</option>
            <option value="descend" selected="true">descending order</option>
            <option value="ascend">ascending order</option>
        </param>
    </xml>

    <xml name="minMappingQuality">
        <param argument="--minMappingQuality" type="integer" optional="true" value="1" min="0"
            label="Minimum mapping quality"
            help= "If set, only reads with a mapping quality score at least this high are considered."/>
    </xml>

    <xml name="skipZeros">
        <param argument="--skipZeros" type="boolean" truevalue="--skipZeros" falsevalue=""
            label ="Skip zeros"
            help ="If set, then zero counts that happen for *all* BAM/CRAM files given are ignored. This may result in fewer considered regions." />
    </xml>

    <xml name="fragmentLength">
        <param argument="--fragmentLength" type="integer" min="1" optional="true"
            label="Fragment length used for the sequencing"
            help ="If paired-end reads are used, the fragment length is computed from the BAM/CRAM file, so this is only needed for single-end data."/>
    </xml>

    <xml name="scaleFactor">
        <param argument="--scaleFactor" type="float" value="1" label="Scaling factor"
            help="The computed scaling factor will be multiplied by this (default 1)." />
    </xml>

    <xml name="scaleFactors">
        <param name="scaleFactor1" type="float" value="1" label="Scale factor for treatment" help="(--scaleFactors)"/>
        <param name="scaleFactor2" type="float" value="1" label="Scale factor for input" help="(--scaleFactors)"/>
    </xml>

    <xml name="stdio">
        <stdio>
            <exit_code range="1:" />
            <exit_code range=":-1" />
            <regex match="Error:" />
            <regex match="Exception:" />
            <regex match="EXception:" />
            <regex match="Traceback" />
        </stdio>
    </xml>

    <xml name="pseudocount">
        <param argument="--pseudocount" type="float" value="1" label="Pseudocount" help="Small number to avoid dividing by zero."/>
    </xml>

    <token name="@REFERENCES@">

.. class:: infomark

For more information on the tools, please visit our `help site`_.

If you would like to give us feedback or you run into any trouble, please send an email to deeptools@googlegroups.com

This tool is developed by the `Bioinformatics and Deep-Sequencing Unit`_ at the `Max Planck Institute for Immunobiology and Epigenetics`_.

.. _Bioinformatics and Deep-Sequencing Unit: http://www.ie-freiburg.mpg.de/bioinformaticsfac
.. _Max Planck Institute for Immunobiology and Epigenetics: http://www3.ie-freiburg.mpg.de
.. _help site: https://deeptools.readthedocs.org/

    </token>
    <xml name="citations">
        <citations>
            <citation type="doi">10.1093/nar/gkw257</citation>
            <yield />
        </citations>
    </xml>

    <xml name="multiple_input_bams" tokens="MIN">
        <conditional name="multibam_conditional">
        <param name="orderMatters" type="select" label="Sample order matters" help="By default, the order of samples given to the program is dependent on their order in your history. If the order of the samples is vital to you, select Yes below.">
            <option value="No" selected="true">No</option>
            <option value="Yes">Yes</option>
        </param>
        <when value="No">
            <param argument="--bamfiles" type="data" format="bam,cram" min="@MIN@"
                label="BAM/CRAM file" multiple="true"
                help=""/>
        </when>
        <when value="Yes">
            <repeat name="multibam_repeats" min="@MIN@" title="BAM/CRAM Files">
                <param argument="--bamfiles" type="data" format="bam,cram" label="BAM/CRAM file" help="" />
            </repeat>
        </when>
        </conditional>
    </xml>

    <xml name="multiple_input_bigwigs" tokens="MIN,LABEL,TITLE">
        <conditional name="multibigwig_conditional">
        <param name="orderMatters" type="select" label="Sample order matters" help="By default, the order of samples given to the program is dependent on their order in your history. If the order of the samples
is vital to you, select Yes below.">
            <option value="No" selected="true">No</option>
            <option value="Yes">Yes</option>
        </param>
        <when value="No">
            <param argument="--bigwigfiles" type="data" format="bigwig" multiple="True" min="@MIN@"
                label="@LABEL@"
                help="You can generate a bigWig file from a BAM/CRAM file using the bamCoverage tool."/>
        </when>
        <when value="Yes">
            <repeat name="multibigwig_repeats" min="@MIN@" title="@TITLE@">
                <param argument="--bigwigfiles" type="data" format="bigwig" label="@LABEL@" help="You can generate a bigWig file from a BAM/CRAM file using the bamCoverage tool."/>
            </repeat>
        </when>
        </conditional>
    </xml>

    <xml name="plotTitle">
        <param argument="--plotTitle" type="text" value="" size="30" optional="True"
            label="Title of the plot"
            help="Title of the plot, to be printed on top of the generated image." />
    </xml>

    <xml name="labelRotation">
        <param argument="--labelRotation" type="integer" value="0"
            label="Rotation of the X-axis labels (in degrees)"
            help="The rotation of things like TSS or TES on the X-axis of profile plots in both plotHeatmap and plotProfile. The default is 0, positive values denome a counter-clockwise rotation." />
    </xml>


    <token name="@multiple_input_bams@">
<![CDATA[
        #set files=[]
        #set labels=[]
        #import re
        #if $multibam_conditional.orderMatters == "No":
            #for $counter, $bamfile in enumerate($multibam_conditional.bamfiles):
                #set identifier = re.sub('[^\.\s\w\-]', '_', str($bamfile.element_identifier))
                ln -s '${bamfile}' './${counter}.bam' &&
                #if $bamfile.ext == 'bam':
                    ln -s '${bamfile.metadata.bam_index}' './${counter}.bam.bai' &&
                #else:
                    ln -s '${bamfile.metadata.cram_index}' './${counter}.bam.crai' &&
                #end if
                #silent $files.append("'%s.bam'" % $counter)
                #silent $labels.append("'%s'" % identifier)
            #end for
        #else:
            #for $counter, $f in enumerate($multibam_conditional.multibam_repeats):
                #set identifier = re.sub('[^\.\s\w\-]', '_', str($f.bamfiles.element_identifier))
                ln -s '${f.bamfiles}' './${counter}.bam' &&
                #if $f.bamfiles.ext == 'bam':
                    ln -s '${f.bamfiles.metadata.bam_index}' './${counter}.bam.bai' &&
                #else:
                    ln -s '${f.bamfiles.metadata.cram_index}' './${counter}.bam.crai' &&
                #end if
                #silent $files.append("'%s.bam'" % $counter)
                #silent $labels.append("'%s'" % $identifier)
            #end for
        #end if
]]>
    </token>

    <token name="@multiple_input_bigwigs@">
<![CDATA[
        #set files=[]
        #set labels=[]
        #import re
        #if $multibigwig_conditional.orderMatters == "No":
            #for $counter, $bigwig in enumerate($multibigwig_conditional.bigwigfiles):
                #set identifier = re.sub('[^\.\s\w\-]', '_', str($bigwig.element_identifier))
                ln -f -s '${bigwig}' '${identifier}_${counter}.bw' &&
                #silent $files.append("'%s_%s.bw'" % ($identifier, $counter))
                #silent $labels.append("'%s'" % $identifier)
            #end for
        #else:
            #for $counter, $f in enumerate($multibigwig_conditional.multibigwig_repeats):
                #set identifier = re.sub('[^\.\s\w\-]', '_', str($f.bigwigfiles.element_identifier))
                ln -f -s '${f.bigwigfiles}' '${identifier}_${counter}.bw' &&
                #silent $files.append("'%s_%s.bw'" % ($identifier, $counter))
                #silent $labels.append("'%s'" % $identifier)
            #end for
        #end if
]]>
    </token>

    <xml name="blacklist">
        <param argument="--blackListFileName" type="data" format="bed,gtf" multiple="true" optional="true" min="0"
            label="Blacklisted regions in BED/GTF format"
            help="One or more files containing regions to exclude from the analysis" />
    </xml>

    <token name="@blacklist@">
<![CDATA[
        #if ' '.join( map(str, $advancedOpt.blackListFileName) ) != 'None':
            #set blfiles=[]
            #for $f in $advancedOpt.blackListFileName:
                #silent $blfiles.append("'%s'" % $f)
            #end for
            #if $blfiles != ["'None'"]:
                --blackListFileName #echo ' '.join($blfiles)#
            #end if
        #end if
]]>
    </token>

    <xml name="multiple_bed">
        <param argument="--BED" type="data" format="bed,gtf" min="1" multiple="true"
            label="Regions in BED/GTF format"
            help="One or more files containing regions to include in the analysis" />
    </xml>

    <token name="@multiple_bed@">
<![CDATA[
        #set files=[]
        #set labels=[]
        #for $f in $BED:
            #silent $files.append("'%s'" % $f)
            #silent $labels.append("'%s'" % $f.display_name)
        #end for
        #if len($files) > 0:
            --BED #echo ' '.join($files)#
            --regionLabels #echo ' '.join($labels)#
        #end if
]]>
    </token>

    <xml name="reference_genome_source">
        <conditional name="source">
            <param name="ref_source" type="select" label="Reference genome">
                <option value="cached">locally cached</option>
                <option value="history">in your history</option>
            </param>
            <when value="cached">
                <param name="input1_2bit" type="select" label="Using reference genome" help="If your genome of interest is not listed, contact the Galaxy team">
                    <options from_data_table="lastz_seqs">
                        <filter type="sort_by" column="1" />
                        <validator type="no_options" message="No indexes are available." />
                    </options>
                </param>
            </when>
            <when value="history">
                <param name="input1" type="data" format="twobit" label="Select a reference dataset in 2bit format" />
            </when>
        </conditional>
    </xml>

    <token name="@reference_genome_source@">
    #if $source.ref_source=="history":
        --genome $source.input1
    #else:
        --genome '$source.input1_2bit.fields.path'
    #end if
    </token>

    <xml name="effectiveGenomeSize">
        <conditional name="effectiveGenomeSize">
            <param name="effectiveGenomeSize_opt" type="select" label="Effective genome size"
                help="The effective genome size is the portion of the genome that is mappable. Large fractions of the genome are stretches of NNNN that should be discarded.
                    Also, if repetitive regions were not included in the mapping of reads, the effective genome size needs to be adjusted accordingly.
                    We provide a table of useful sizes here: http://deeptools.readthedocs.io/en/latest/content/feature/effectiveGenomeSize.html">
                <option value="93260000">ce10 (93260000)</option>
                <option value="130428560">dm3 (130428560)</option>
                <option value="125464728">dm6 (125464728)</option>
                <option value="2685511504" selected="true">hg19/GRCh37 (2685511504)</option>
                <option value="2701495761">GRCh38/hg38 (2701495761)</option>
                <option value="2304947926">GRCm37/mm9 (2304947926)</option>
                <option value="2308125349">GRCm38/mm10 (2308125349)</option>
                <option value="specific">user specified</option>
            </param>
            <when value="specific">
                <param argument="--effectiveGenomeSize" type="integer" value="" label="Effective genome size"
                       help="e.g. ce10: 93260000, dm3: 130428560, hg19: 2685511504, mm9: 2304947926"/>
            </when>
            <when value="93260000" />
            <when value="130428560" />
            <when value="125464728" />
            <when value="2685511504" />
            <when value="2701495761" />
            <when value="2304947926" />
            <when value="2308125349" />
        </conditional>
    </xml>

    <xml name="skipNAs">
        <param argument="--skipNAs" type="boolean" truevalue="--skipNAs" falsevalue="" checked="False"
            label="Ignore missing data?"
            help="This parameter determines if non-covered regions
                 (regions without overlapping reads) in a bam/bigWig file
                 should be skipped. The default is to treat those
                 regions as having a value of zero. The decision to
                 skip non-covered regions depends on the interpretation
                 of the data. Non-covered regions may represent, for
                 example, repetitive regions that should be ignored.
                 (default: False)" />
    </xml>

    <xml name="input_save_matrix_values">
        <param argument="--saveMatrix" type="boolean" label="Save the matrix of values underlying the heatmap"/>
    </xml>

    <xml name="input_graphic_output_settings">
        <conditional name="output" >
            <param name="showOutputSettings" type="select" label="Show advanced output settings" >
                <option value="no" selected="true">no</option>
                <option value="yes">yes</option>
            </param>
            <when value="no" />
            <when value="yes">
                <yield />
                <param name="saveSortedRegions" type="boolean"
                       argument="--outFileSortedRegions"
                       label="Save the regions after skipping zeros or min/max threshold values"
                       help="The order of the regions in the file follows the sorting order selected. This is useful,
                       for example, to generate other heatmaps keeping the sorting of the first heatmap."/>
            </when>
        </conditional>
    </xml>


    <xml name="input_image_file_format">
        <param argument="--outFileFormat" type="select" label="Image file format" help="Note that the plotly output can be very large and not all options are supported.">
            <option value="png" selected="true">png</option>
            <option value="pdf">pdf</option>
            <option value="svg">svg</option>
            <option value="eps">eps</option>
            <option value="plotly">plotly</option>
        </param>
    </xml>

    <xml name="output_dpi">
        <param argument="--dpi" name="dpi" type="integer" value="200" size="3" optional="True"
            label="Image dpi" help=""/>
    </xml>

    <xml name="output_image_file_format">
        <data format="png" name="outFileName" label="${tool.name} image">
            <change_format>
                <when input="output.outFileFormat" value="pdf" format="pdf" />
                <when input="output.outFileFormat" value="svg" format="svg" />
                <when input="output.outFileFormat" value="eps" format="eps" />
                <when input="output.outFileFormat" value="plotly" format="html" />
            </change_format>
        </data>
    </xml>

    <xml name="output_image_file_format_not_nested">
        <data format="png" name="outFileName" label="${tool.name} image">
            <change_format>
                <when input="outFileFormat" value="pdf" format="pdf" />
                <when input="outFileFormat" value="svg" format="svg" />
                <when input="outFileFormat" value="eps" format="eps" />
                <when input="outFileFormat" value="plotly" format="html" />
            </change_format>
        </data>
    </xml>

    <xml name="output_save_matrix_values">
        <data format="tabular" name="outFileNameMatrix" label="${tool.name} on ${on_string}: Heatmap values">
            <filter>
            ((
                output['showOutputSettings'] == 'yes' and
                output['saveMatrix'] is True
            ))
            </filter>
        </data>
    </xml>

    <xml name="output_graphic_outputs">
        <data format="bed" name="outFileSortedRegions" label="${tool.name} on ${on_string}: sorted/filtered regions">
            <filter>
            ((
                output['showOutputSettings'] == 'yes' and
                output['saveSortedRegions'] is True
            ))
            </filter>
        </data>
    </xml>

    <xml name="colorMap">
        <param name="colorMap" type="select" label="Color map to use for the heatmap"
               help=" Available color map names can be found here: http://matplotlib.org/examples/color/colormaps_reference.html">
            <option value="RdYlBu" selected="true">RdYlBu</option>
            <option value="Accent">Accent</option>
            <option value="Spectral">Spectral</option>
            <option value="Set1">Set1</option>
            <option value="Set2">Set2</option>
            <option value="Set3">Set3</option>
            <option value="Dark2">Dark2</option>
            <option value="Reds">Reds</option>
            <option value="Oranges">Oranges</option>
            <option value="Greens">Greens</option>
            <option value="Blues">Blues</option>
            <option value="Greys">Greys</option>
            <option value="Purples">Purples</option>
            <option value="Paired">Paired</option>
            <option value="Pastel1">Pastel1</option>
            <option value="Pastel2">Pastel2</option>
            <option value="spring">spring</option>
            <option value="summer">summer</option>
            <option value="autumn">autumn</option>
            <option value="winter">winter</option>
            <option value="hot">hot</option>
            <option value="coolwarm">coolwarm</option>
            <option value="cool">cool</option>
            <option value="seismic">seismic</option>
            <option value="terrain">terrain</option>
            <option value="ocean">ocean</option>
            <option value="rainbow">rainbow</option>
            <option value="bone">bone</option>
            <option value="flag">flag</option>
            <option value="prism">prism</option>
            <option value="cubehelix">cubehelix</option>
            <option value="binary">binary</option>
            <option value="pink">pink</option>
            <option value="gray">gray</option>
            <option value="copper">copper</option>
            <option value="BrBG">BrBG</option>
            <option value="BuGn">BuGn</option>
            <option value="BuPu">BuPu</option>
            <option value="GnBu">GnBu</option>
            <option value="OrRd">OrRd</option>
            <option value="PiYG">PiYG</option>
            <option value="PRGn">PRGn</option>
            <option value="PuOr">PuOr</option>
            <option value="PuRd">PuRd</option>
            <option value="PuBu">PuBu</option>
            <option value="RdBu">RdBu</option>
            <option value="RdGy">RdGy</option>
            <option value="RdPu">RdPu</option>
            <option value="YlGn">YlGn</option>
            <option value="PuBuGn">PuBuGn</option>
            <option value="RdYlGn">RdYlGn</option>
            <option value="YlGnBu">YlGnBu</option>
            <option value="YlOrBr">YlOrBr</option>
            <option value="YlOrRd">YlOrRd</option>
            <option value="gist_gray">gist_gray</option>
            <option value="gist_stern">gist_stern</option>
            <option value="gist_earth">gist_earth</option>
            <option value="gist_yarg">gist_yarg</option>
            <option value="gist_ncar">gist_ncar</option>
            <option value="gist_rainbow">gist_rainbow</option>
            <option value="gist_heat">gist_heat</option>
            <option value="gnuplot">gnuplot</option>
            <option value="gnuplot2">gnuplot2</option>
            <option value="CMRmap">CMRmap</option>
            <option value="bwr">bwr</option>
            <option value="hsv">hsv</option>
            <option value="brg">brg</option>
            <option value="jet">jet</option>
            <option value="afmhot">afmhot</option>
            <option value="Accent_r">Accent reversed</option>
            <option value="Spectral_r">Spectral reversed</option>
            <option value="Set1_r">Set1 reversed</option>
            <option value="Set2_r">Set2 reversed</option>
            <option value="Set3_r">Set3 reversed</option>
            <option value="Dark2_r">Dark2 reversed</option>
            <option value="Reds_r">Reds reversed</option>
            <option value="Oranges_r">Oranges reversed</option>
            <option value="Greens_r">Greens reversed</option>
            <option value="Blues_r">Blues reversed</option>
            <option value="Greys_r">Greys reversed</option>
            <option value="Purples_r">Purples reversed</option>
            <option value="Paired_r">Paired reversed</option>
            <option value="Pastel1_r">Pastel1 reversed</option>
            <option value="Pastel2_r">Pastel2 reversed</option>
            <option value="spring_r">spring reversed</option>
            <option value="summer_r">summer reversed</option>
            <option value="autumn_r">autumn reversed</option>
            <option value="winter_r">winter reversed</option>
            <option value="hot_r">hot reversed</option>
            <option value="coolwarm_r">coolwarm reversed</option>
            <option value="cool_r">cool reversed</option>
            <option value="seismic_r">seismic reversed</option>
            <option value="terrain_r">terrain reversed</option>
            <option value="ocean_r">ocean reversed</option>
            <option value="rainbow_r">rainbow reversed</option>
            <option value="bone_r">bone reversed</option>
            <option value="flag_r">flag reversed</option>
            <option value="prism_r">prism reversed</option>
            <option value="cubehelix_r">cubehelix reversed</option>
            <option value="binary_r">binary reversed</option>
            <option value="pink_r">pink reversed</option>
            <option value="gray_r">gray reversed</option>
            <option value="copper_r">copper reversed</option>
            <option value="BrBG_r">BrBG reversed</option>
            <option value="BuGn_r">BuGn reversed</option>
            <option value="BuPu_r">BuPu reversed</option>
            <option value="GnBu_r">GnBu reversed</option>
            <option value="OrRd_r">OrRd reversed</option>
            <option value="PiYG_r">PiYG reversed</option>
            <option value="PRGn_r">PRGn reversed</option>
            <option value="PuOr_r">PuOr reversed</option>
            <option value="PuRd_r">PuRd reversed</option>
            <option value="PuBu_r">PuBu reversed</option>
            <option value="RdBu_r">RdBu reversed</option>
            <option value="RdGy_r">RdGy reversed</option>
            <option value="RdPu_r">RdPu reversed</option>
            <option value="YlGn_r">YlGn reversed</option>
            <option value="PuBuGn_r">PuBuGn reversed</option>
            <option value="RdYlBu_r">RdYlBu reversed</option>
            <option value="RdYlGn_r">RdYlGn reversed</option>
            <option value="YlGnBu_r">YlGnBu reversed</option>
            <option value="YlOrBr_r">YlOrBr reversed</option>
            <option value="YlOrRd_r">YlOrRd reversed</option>
            <option value="gist_gray_r">gist_gray reversed</option>
            <option value="gist_stern_r">gist_stern reversed</option>
            <option value="gist_earth_r">gist_earth reversed</option>
            <option value="gist_yarg_r">gist_yarg reversed</option>
            <option value="gist_ncar_r">gist_ncar reversed</option>
            <option value="gist_rainbow_r">gist_rainbow reversed</option>
            <option value="gist_heat_r">gist_heat reversed</option>
            <option value="gnuplot_r">gnuplot reversed</option>
            <option value="gnuplot2_r">gnuplot2 reversed</option>
            <option value="CMRmap_r">CMRmap reversed</option>
            <option value="bwr_r">bwr reversed</option>
            <option value="hsv_r">hsv reversed</option>
            <option value="brg_r">brg reversed</option>
            <option value="jet_r">jet reversed</option>
            <option value="afmhot_r">afmhot reversed</option>
        </param>

    </xml>

</macros>
